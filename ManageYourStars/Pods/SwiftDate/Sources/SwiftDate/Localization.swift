// SwiftDate
// Manage Date/Time & Timezone in Swift
//
// Created by: Daniele Margutti
// Email: <hello@danielemargutti.com>
// Web: <http://www.danielemargutti.com>
//
// Licensed under MIT License.

import Foundation

/// This class allows you to read and load a custom `.strings` file or a file generated by a gived `Locale` instance.
public class Localization {
	
	/// Translations file loaded from a custom `.strings` file.
	/// It has a valid value only if `Localization` is loaded from a file.
	private var translations: NSDictionary?
	
	/// Bundle for given locale instances
	private var bundle: Bundle?
	/// Locale instances loaded (only if initialized via Locale instance)
	private(set) var locale: Locale?
	
	
	/// Init `Localization` instance from a custom `.strings` file at given path
	///
	/// - Parameter path: path to a strings file
	/// - Throws: throw an exception if not valid `strings` file was loaded.
	public init(path: String) throws {
		guard let data = NSDictionary(contentsOfFile: path) else {
			throw DateError.InvalidLocalizationFile
		}
		translations = data
	}
	
	
	/// Initialize a new `Localization` from a given `LocaleName`
	///
	/// - Parameter name: name of locale
	public convenience init(locale name: LocaleName) {
		self.init(locale: name.locale)
	}
	
	
	/// Init `Localization` instance with a given `locale` instance
	///
	/// - Parameter locale: locale to load; if `nil` current `locale` is used instead.
	public init(locale: Locale?) {
		self.locale = locale ?? Locale.current
		
		let resourceBundle = Localization.resourceBundle()!
		let localeID = self.locale!.collatorIdentifier?.replacingOccurrences(of: "_", with: "-")
		guard let innerLanguagePath = resourceBundle.path(forResource: localeID, ofType: "lproj") else {
			
			//fallback to language only
			if let languageCode = self.locale!.languageCode {
				//example : get french traduction even though you are live in belgium
				if let localOnlyPath = resourceBundle.path(forResource: "\(languageCode)-\(languageCode.uppercased())"  , ofType: "lproj") {
					self.bundle = Bundle(path: localOnlyPath)
					return
				}
				// Sigle locale (ie. 'ar')
				if let localOnlyPath = resourceBundle.path(forResource: "\(languageCode)"  , ofType: "lproj") {
					self.bundle = Bundle(path: localOnlyPath)
					return
				}
			}
			// fallback to english if language was not found
			let englishPath = resourceBundle.path(forResource: "en-US", ofType: "lproj")!
			self.bundle = Bundle(path: englishPath)
			return
		}
		self.bundle = Bundle(path: innerLanguagePath)
	}
	
	
	/// Get translated value for a given key
	///
	/// - Parameters:
	///   - key: key to search
	///   - defValue: default fallback value. By default is empty string.
	/// - Returns: translated value
	public func get(_ key: String, default defValue: String = "") -> String {
		if translations != nil {
			guard let value = translations!.object(forKey: key) as? String else {
				return defValue
			}
			return value
		} else {
			guard let bundle = self.bundle else {
				return defValue
			}
			let value =  NSLocalizedString(key, tableName: "SwiftDate", bundle: bundle, value: "", comment: "")
			return value
		}
	}
	
	
	/// Framework's translation bundle resource
	///
	/// - Returns: path
	private class func resourceBundle() -> Bundle? {
		let framework = Bundle(for: DateInRegion.self)
		let path = NSURL(fileURLWithPath: framework.resourcePath!).appendingPathComponent("SwiftDate.bundle")
		let bundle = Bundle(url: path!)
		guard let _ = bundle else {
			return nil
		}
		return bundle!
	}
	
	internal func localizedString(identifier: String, arguments: CVarArg...) -> String? {
		var localized_str = self.get(identifier, default: "")
		localized_str = String(format: localized_str, arguments: arguments)
		return localized_str
	}
	
}
